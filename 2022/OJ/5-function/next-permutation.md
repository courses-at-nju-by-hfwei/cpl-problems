# 下一个排列（next-permutation.c）

## 题目描述

给出一个长度为 $n$ 的排列 $p_1, p_2, \cdots, p_n$，请**按照题目注解中给出的方法**，求出这个排列的下一个排列。

一个长度为 $n$ 的序列能被称为排列当且仅当 $ 1, 2, \cdots, n$每个数都恰好出现一次，比如 `1, 2, 3`， `3, 1, 2` 都是长度为 $ 3$ 的排列，而 `2, 2, 1` 则不能被称为一个排列。

本题中的下一个排列是字典序意义上的（[什么是字典序？](https://zh.wikipedia.org/zh-hans/%E5%AD%97%E5%85%B8%E5%BA%8F)），长度为 $ n$ 的排列一共有 $ n!$ 个，将排列中的所有数连成一个字符串，并将这 $n !$ 个串排序，我们可以得到一个长度为 $ n!$ 的升序字符串序列，本题要求你输出给出的排列的下一个排列。

## 输入格式

输入一共包括两行。

第一行为一个整数 $n(n \leq 2000)$，表示排列的长度。

第二行为 $ n$ 个整数，$p_1, p_2, \cdots, p_n$，表示给出的排列。

保证给出的排列都能找出下一个排列，形式化地说，给出的排列 $p_1, p_2, \cdots, p_n$ **不满足** $\forall 1 \leq i \leq n, p_i = n - i + 1$。

## 输出格式

输出包括一行 $n$ 个整数，表示给出的排列的下一个排列。

## 备注

### 求下一个排列的方法

- 找出给出的排列的最长连续递降后缀，其长度记为 $m(m < n)$。
- 找到最长递降后缀的之前的那个数，记为 $p_k$，在最长递降后缀中找到比 $p_k$ 大的数中最小的那个，交换这两个数。
- 将**交换后的序列**的后 $m$ 个数翻转。

举个例子，假如给出的排列为`1 3 5 4 2`，最长递降后缀为`5 4 2`，最长递降后缀不为`3 5 4 2`，因为`3 5`不递降；最长递降后缀不为`4 2`，因为其不满足“最长”的性质。最长递降后缀之前的那个数为`3`，找到最长递降后缀中比`3`大的那个数中最小的那个：`4`，交换后为`1 4 5 3 2`，将这个序列中后3位翻转后得到`1 4 2 3 5`，即为最后答案。

### 思考题

怎么证明这个做法是对的？或怎么证明我们求出的序列恰好是“下一个排列”。

## 示例

### 示例输入1

```text
5
3 1 2 4 5
```

### 示例输出1

```text
3 1 2 5 4
```

### 示例输入2

```text
3
1 2 3
```

### 示例输出2

```text
1 3 2
```

### 示例输入3

```text
9
6 3 1 5 8 9 4 2 7
```

### 示例输出3

```text
6 3 1 5 8 9 4 7 2
```

### 示例输入4

```text
9
6 3 1 5 4 9 8 7 2
```

### 示例输出4

```text
6 3 1 5 7 2 4 8 9
```